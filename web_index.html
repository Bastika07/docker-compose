<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LanCache Monitor Dashboard</title>
    <link rel="stylesheet" href="web_style.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1>🚀 LanCache Monitor Dashboard</h1>
            <div class="status-indicator" id="statusDot">●</div>
            <span id="statusText">Verbindung prüfen...</span>
        </header>

        <div class="stats-grid">
            <!-- Gesamt-Statistiken -->
            <div class="stat-card">
                <h3>📊 Gesamt-Requests</h3>
                <div class="stat-value" id="totalRequests">-</div>
                <div class="stat-label">Total Requests</div>
            </div>

            <div class="stat-card">
                <h3>🎯 Cache Hit Rate</h3>
                <div class="stat-value" id="hitRate">-</div>
                <div class="stat-label">Global Hit Rate</div>
            </div>

            <div class="stat-card">
                <h3>💾 Cache Hits</h3>
                <div class="stat-value" id="cacheHits">-</div>
                <div class="stat-label">Total Hits</div>
            </div>

            <div class="stat-card">
                <h3>❌ Cache Misses</h3>
                <div class="stat-value" id="cacheMisses">-</div>
                <div class="stat-label">Total Misses</div>
            </div>

            <div class="stat-card">
                <h3>📦 Bytes Served</h3>
                <div class="stat-value" id="bytesServed">-</div>
                <div class="stat-label">Total Bytes</div>
            </div>

            <div class="stat-card">
                <h3>🔗 Active Connections</h3>
                <div class="stat-value" id="activeConnections">-</div>
                <div class="stat-label">Current Connections</div>
            </div>

            <div class="stat-card">
                <h3>⏱️ Uptime</h3>
                <div class="stat-value" id="uptime">-</div>
                <div class="stat-label">Monitor Uptime</div>
            </div>

            <div class="stat-card">
                <h3>🌐 CDN Count</h3>
                <div class="stat-value" id="cdnCount">-</div>
                <div class="stat-label">Active CDNs</div>
            </div>
        </div>

        <!-- CDN-spezifische Statistiken -->
        <div class="section">
            <h2>📦 CDN-spezifische Statistiken</h2>
            <div id="cdnStats" class="cdn-grid">
                <!-- Wird dynamisch gefüllt -->
            </div>
        </div>

        <!-- Charts -->
        <div class="charts-section">
            <div class="chart-container">
                <h3>📈 Hit Rate Trend</h3>
                <canvas id="hitRateChart"></canvas>
            </div>
            
            <div class="chart-container">
                <h3>🎯 CDN Hit Rates</h3>
                <canvas id="cdnChart"></canvas>
            </div>
        </div>

        <!-- Debug Sektion -->
        <div class="section">
            <h2>🔧 Debug Information</h2>
            <div class="debug-info">
                <p><strong>Metrics URL:</strong> <span id="metricsUrl">-</span></p>
                <p><strong>Last Update:</strong> <span id="lastUpdate">-</span></p>
                <p><strong>Update Interval:</strong> <span id="updateInterval">10s</span></p>
                <p><strong>Status:</strong> <span id="debugStatus">-</span></p>
            </div>
            
            <button onclick="testConnection()" class="test-button">🧪 Test Connection</button>
            <button onclick="showRawMetrics()" class="test-button">📄 Show Raw Metrics</button>
            <button onclick="toggleAutoRefresh()" class="test-button" id="refreshButton">⏸️ Pause Refresh</button>
        </div>

        <!-- Raw Metrics Modal -->
        <div id="rawMetricsModal" class="modal">
            <div class="modal-content">
                <span class="close" onclick="closeModal()">&times;</span>
                <h2>📄 Raw Prometheus Metrics</h2>
                <pre id="rawMetricsContent">Loading...</pre>
            </div>
        </div>
    </div>

    <script>
        // Konfiguration
        const CONFIG = {
            metricsUrl: '/metrics',  // Relativer Pfad für Proxy
            fallbackUrl: 'http://192.168.100.117:9114/metrics',  // Fallback
            updateInterval: 10000,
            maxDataPoints: 50
        };

        // Globale Variablen
        let metricsData = {};
        let updateTimer;
        let hitRateChart;
        let cdnChart;
        let hitRateHistory = [];
        let autoRefresh = true;

        // Chart-Initialisierung
        function initCharts() {
            // Hit Rate Trend Chart
            const hitRateCtx = document.getElementById('hitRateChart').getContext('2d');
            hitRateChart = new Chart(hitRateCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Hit Rate (%)',
                        data: [],
                        borderColor: '#4CAF50',
                        backgroundColor: 'rgba(76, 175, 80, 0.1)',
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100
                        }
                    }
                }
            });

            // CDN Chart
            const cdnCtx = document.getElementById('cdnChart').getContext('2d');
            cdnChart = new Chart(cdnCtx, {
                type: 'doughnut',
                data: {
                    labels: [],
                    datasets: [{
                        data: [],
                        backgroundColor: [
                            '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', 
                            '#9966FF', '#FF9F40', '#FF6384', '#C9CBCF'
                        ]
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: {
                            position: 'bottom'
                        }
                    }
                }
            });
        }

        // Metriken abrufen und parsen
        async function fetchMetrics() {
            const metricsUrl = document.getElementById('metricsUrl').textContent || CONFIG.metricsUrl;
            
            try {
                let response;
                
                // Versuche zunächst relativen Pfad (Proxy)
                try {
                    response = await fetch(CONFIG.metricsUrl);
                    if (!response.ok) throw new Error('Proxy failed');
                } catch (proxyError) {
                    // Fallback auf direkte URL
                    response = await fetch(CONFIG.fallbackUrl);
                }

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const text = await response.text();
                document.getElementById('debugStatus').textContent = `✅ OK (${response.status})`;
                document.getElementById('metricsUrl').textContent = response.url;
                
                return parsePrometheusMetrics(text);
                
            } catch (error) {
                console.error('Fehler beim Abrufen der Metriken:', error);
                document.getElementById('debugStatus').textContent = `❌ Error: ${error.message}`;
                throw error;
            }
        }

        // Prometheus-Metriken parsen
        function parsePrometheusMetrics(text) {
            const metrics = {};
            const lines = text.split('\n');

            lines.forEach(line => {
                // Überspringe Kommentare und leere Zeilen
                if (line.startsWith('#') || !line.trim()) return;

                // Parse Metrik-Zeile: metric_name{labels} value
                const match = line.match(/^([a-zA-Z_:][a-zA-Z0-9_:]*)(\{.*?\})?\s+([\d\.-]+)$/);
                if (!match) return;

                const [, name, labelsStr, value] = match;
                const labels = parseLabels(labelsStr || '');

                if (!metrics[name]) metrics[name] = [];
                metrics[name].push({
                    labels,
                    value: parseFloat(value)
                });
            });

            return metrics;
        }

        // Labels parsen
        function parseLabels(labelsStr) {
            const labels = {};
            if (!labelsStr) return labels;

            const cleanStr = labelsStr.slice(1, -1); // Entferne { }
            const pairs = cleanStr.match(/\w+="[^"]*"/g) || [];

            pairs.forEach(pair => {
                const [key, value] = pair.split('=');
                labels[key] = value.slice(1, -1); // Entferne Anführungszeichen
            });

            return labels;
        }

        // UI aktualisieren
        function updateUI(metrics) {
            metricsData = metrics;

            // Gesamt-Statistiken
            updateTotalRequests(metrics);
            updateHitRate(metrics);
            updateCacheStats(metrics);
            updateBytesServed(metrics);
            updateActiveConnections(metrics);
            updateUptime(metrics);
            updateCDNStats(metrics);

            // Charts aktualisieren
            updateCharts(metrics);

            // Status
            document.getElementById('statusDot').className = 'status-indicator online';
            document.getElementById('statusText').textContent = 'Online';
            document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
        }

        function updateTotalRequests(metrics) {
            const requests = metrics['lancache_requests_total'] || [];
            const total = requests.reduce((sum, metric) => sum + metric.value, 0);
            document.getElementById('totalRequests').textContent = formatNumber(total);
        }

        function updateHitRate(metrics) {
            const hitRate = metrics['lancache_hit_rate'];
            if (hitRate && hitRate.length > 0) {
                const rate = (hitRate[0].value * 100).toFixed(1);
                document.getElementById('hitRate').textContent = `${rate}%`;
                
                // Hit Rate History für Chart
                const now = new Date().toLocaleTimeString();
                hitRateHistory.push({ time: now, rate: parseFloat(rate) });
                if (hitRateHistory.length > CONFIG.maxDataPoints) {
                    hitRateHistory.shift();
                }
            } else {
                // Fallback: Berechne aus Hits/Misses
                const hits = metrics['lancache_cache_hits_total'] || [];
                const misses = metrics['lancache_cache_misses_total'] || [];
                
                const totalHits = hits.reduce((sum, metric) => sum + metric.value, 0);
                const totalMisses = misses.reduce((sum, metric) => sum + metric.value, 0);
                const totalRequests = totalHits + totalMisses;
                
                if (totalRequests > 0) {
                    const rate = ((totalHits / totalRequests) * 100).toFixed(1);
                    document.getElementById('hitRate').textContent = `${rate}%`;
                } else {
                    document.getElementById('hitRate').textContent = '0%';
                }
            }
        }

        function updateCacheStats(metrics) {
            const hits = metrics['lancache_cache_hits_total'] || [];
            const misses = metrics['lancache_cache_misses_total'] || [];

            const totalHits = hits.reduce((sum, metric) => sum + metric.value, 0);
            const totalMisses = misses.reduce((sum, metric) => sum + metric.value, 0);

            document.getElementById('cacheHits').textContent = formatNumber(totalHits);
            document.getElementById('cacheMisses').textContent = formatNumber(totalMisses);
        }

        function updateBytesServed(metrics) {
            const bytes = metrics['lancache_bytes_total'] || [];
            const totalBytes = bytes.reduce((sum, metric) => sum + metric.value, 0);
            document.getElementById('bytesServed').textContent = formatBytes(totalBytes);
        }

        function updateActiveConnections(metrics) {
            const connections = metrics['lancache_active_connections'];
            if (connections && connections.length > 0) {
                document.getElementById('activeConnections').textContent = formatNumber(connections[0].value);
            } else {
                document.getElementById('activeConnections').textContent = '0';
            }
        }

        function updateUptime(metrics) {
            const uptime = metrics['lancache_uptime_seconds'];
            if (uptime && uptime.length > 0) {
                document.getElementById('uptime').textContent = formatDuration(uptime[0].value);
            } else {
                document.getElementById('uptime').textContent = '-';
            }
        }

        function updateCDNStats(metrics) {
            const cdnContainer = document.getElementById('cdnStats');
            const cdnData = new Map();

            // Sammle CDN-Daten
            ['lancache_cache_hits_total', 'lancache_cache_misses_total', 'lancache_hit_rate_by_cdn'].forEach(metricName => {
                const metricList = metrics[metricName] || [];
                metricList.forEach(metric => {
                    const cdn = metric.labels.cdn;
                    if (!cdn) return;

                    if (!cdnData.has(cdn)) {
                        cdnData.set(cdn, { hits: 0, misses: 0, hitRate: 0 });
                    }

                    const data = cdnData.get(cdn);
                    if (metricName === 'lancache_cache_hits_total') {
                        data.hits = metric.value;
                    } else if (metricName === 'lancache_cache_misses_total') {
                        data.misses = metric.value;
                    } else if (metricName === 'lancache_hit_rate_by_cdn') {
                        data.hitRate = metric.value * 100;
                    }
                });
            });

            // Update CDN Count
            document.getElementById('cdnCount').textContent = cdnData.size;

            // Erstelle CDN-Cards
            cdnContainer.innerHTML = '';
            cdnData.forEach((data, cdn) => {
                const cdnCard = document.createElement('div');
                cdnCard.className = 'cdn-card';
                cdnCard.innerHTML = `
                    <h4>📦 ${cdn.toUpperCase()}</h4>
                    <div class="cdn-stats">
                        <div class="cdn-stat">
                            <span class="label">Hits:</span>
                            <span class="value">${formatNumber(data.hits)}</span>
                        </div>
                        <div class="cdn-stat">
                            <span class="label">Misses:</span>
                            <span class="value">${formatNumber(data.misses)}</span>
                        </div>
                        <div class="cdn-stat">
                            <span class="label">Hit Rate:</span>
                            <span class="value">${data.hitRate.toFixed(1)}%</span>
                        </div>
                    </div>
                `;
                cdnContainer.appendChild(cdnCard);
            });
        }

        function updateCharts(metrics) {
            // Hit Rate Chart
            if (hitRateHistory.length > 0) {
                hitRateChart.data.labels = hitRateHistory.map(h => h.time);
                hitRateChart.data.datasets[0].data = hitRateHistory.map(h => h.rate);
                hitRateChart.update('none');
            }

            // CDN Chart
            const cdnHits = metrics['lancache_cache_hits_total'] || [];
            const cdnLabels = [];
            const cdnValues = [];

            cdnHits.forEach(metric => {
                if (metric.labels.cdn) {
                    cdnLabels.push(metric.labels.cdn.toUpperCase());
                    cdnValues.push(metric.value);
                }
            });

            if (cdnLabels.length > 0) {
                cdnChart.data.labels = cdnLabels;
                cdnChart.data.datasets[0].data = cdnValues;
                cdnChart.update('none');
            }
        }

        // Hilfsfunktionen
        function formatNumber(num) {
            if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
            if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
            return Math.round(num).toString();
        }

        function formatBytes(bytes) {
            const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
            if (bytes === 0) return '0 B';
            const i = Math.floor(Math.log(bytes) / Math.log(1024));
            return Math.round((bytes / Math.pow(1024, i)) * 100) / 100 + ' ' + sizes[i];
        }

        function formatDuration(seconds) {
            const days = Math.floor(seconds / 86400);
            const hours = Math.floor((seconds % 86400) / 3600);
            const mins = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);

            if (days > 0) return `${days}d ${hours}h`;
            if (hours > 0) return `${hours}h ${mins}m`;
            if (mins > 0) return `${mins}m ${secs}s`;
            return `${secs}s`;
        }

        // Event Handler
        async function testConnection() {
            document.getElementById('debugStatus').textContent = '🔄 Testing...';
            try {
                await fetchMetrics();
                alert('✅ Verbindung erfolgreich!');
            } catch (error) {
                alert(`❌ Verbindungsfehler: ${error.message}`);
            }
        }

        async function showRawMetrics() {
            const modal = document.getElementById('rawMetricsModal');
            const content = document.getElementById('rawMetricsContent');
            
            modal.style.display = 'block';
            content.textContent = 'Loading...';
            
            try {
                const response = await fetch(CONFIG.fallbackUrl);
                const text = await response.text();
                content.textContent = text;
            } catch (error) {
                content.textContent = `Error: ${error.message}`;
            }
        }

        function closeModal() {
            document.getElementById('rawMetricsModal').style.display = 'none';
        }

        function toggleAutoRefresh() {
            autoRefresh = !autoRefresh;
            const button = document.getElementById('refreshButton');
            
            if (autoRefresh) {
                button.textContent = '⏸️ Pause Refresh';
                startUpdates();
            } else {
                button.textContent = '▶️ Resume Refresh';
                if (updateTimer) {
                    clearInterval(updateTimer);
                }
            }
        }

        // Main Update Loop
        async function updateData() {
            if (!autoRefresh) return;
            
            try {
                const metrics = await fetchMetrics();
                updateUI(metrics);
            } catch (error) {
                console.error('Update failed:', error);
                document.getElementById('statusDot').className = 'status-indicator offline';
                document.getElementById('statusText').textContent = 'Offline';
                document.getElementById('debugStatus').textContent = `❌ ${error.message}`;
            }
        }

        function startUpdates() {
            updateData(); // Sofortiger erster Update
            updateTimer = setInterval(updateData, CONFIG.updateInterval);
        }

        // Initialisierung
        document.addEventListener('DOMContentLoaded', function() {
            initCharts();
            startUpdates();
            
            // Modal-Handler
            window.onclick = function(event) {
                const modal = document.getElementById('rawMetricsModal');
                if (event.target === modal) {
                    closeModal();
                }
            };
        });
    </script>
</body>
</html>

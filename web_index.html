<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LanCache Monitor Dashboard</title>
    <script src="web_config.js"></script>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1>🚀 LanCache Monitor Dashboard</h1>
            <div class="status-indicator" id="statusDot">●</div>
            <span id="statusText">Verbindung prüfen...</span>
        </header>

        <div class="stats-grid">
            <!-- Gesamt-Statistiken -->
            <div class="stat-card">
                <h3>📊 Gesamt-Requests</h3>
                <div class="stat-value" id="totalRequests">-</div>
                <div class="stat-label">Total Requests</div>
            </div>

            <div class="stat-card">
                <h3>🎯 Cache Hit Rate</h3>
                <div class="stat-value" id="hitRate">-</div>
                <div class="stat-label">Global Hit Rate</div>
            </div>

            <div class="stat-card">
                <h3>💾 Cache Hits</h3>
                <div class="stat-value" id="cacheHits">-</div>
                <div class="stat-label">Total Hits</div>
            </div>

            <div class="stat-card">
                <h3>❌ Cache Misses</h3>
                <div class="stat-value" id="cacheMisses">-</div>
                <div class="stat-label">Total Misses</div>
            </div>

            <div class="stat-card">
                <h3>📦 Bytes Served</h3>
                <div class="stat-value" id="bytesServed">-</div>
                <div class="stat-label">Total Bytes</div>
            </div>

            <div class="stat-card">
                <h3>🔗 Active Connections</h3>
                <div class="stat-value" id="activeConnections">-</div>
                <div class="stat-label">Current Connections</div>
            </div>

            <div class="stat-card">
                <h3>⏱️ Uptime</h3>
                <div class="stat-value" id="uptime">-</div>
                <div class="stat-label">Monitor Uptime</div>
            </div>

            <div class="stat-card">
                <h3>🌐 CDN Count</h3>
                <div class="stat-value" id="cdnCount">-</div>
                <div class="stat-label">Active CDNs</div>
            </div>
        </div>

        <!-- Bandwidth Savings Section -->
        <div class="section-separator">💰 BANDWIDTH SAVINGS</div>
        
        <div class="stats-grid">
            <!-- Bandwidth Savings Cards -->
            <div class="stat-card internet-card">
                <h3>📥 Internet Downloads</h3>
                <div class="stat-value" id="internetDownloads">-</div>
                <div class="stat-label">Cache Downloaded</div>
                <div class="stat-detail" id="internetDownloadsDetail">From upstream</div>
            </div>

            <div class="stat-card savings-card">
                <h3>🔄 Cache Served</h3>
                <div class="stat-value" id="cacheServed">-</div>
                <div class="stat-label">Local Cache Hits</div>
                <div class="stat-detail" id="cacheServedDetail">Served locally</div>
            </div>

            <div class="stat-card highlight-card">
                <h3>💰 Bandwidth Saved</h3>
                <div class="stat-value savings-highlight" id="bandwidthSaved">-</div>
                <div class="stat-label">Total Savings</div>
                <div class="stat-detail" id="savingsDetail">Internet traffic avoided</div>
            </div>

            <div class="stat-card efficiency-card">
                <h3>📊 Efficiency Rate</h3>
                <div class="stat-value" id="efficiencyRate">-</div>
                <div class="stat-label">Bandwidth Efficiency</div>
                <div class="stat-detail" id="efficiencyDetail">Traffic reduction</div>
            </div>

            <div class="stat-card ratio-card">
                <h3>⚖️ Internet vs Cache</h3>
                <div class="stat-value" id="trafficRatio">-</div>
                <div class="stat-label">Traffic Ratio</div>
                <div class="stat-detail" id="ratioDetail">Internet : Cache</div>
            </div>
        </div>

        <!-- CDN-spezifische Statistiken -->
        <div class="section">
            <h2>📦 CDN-spezifische Statistiken</h2>
            <div id="cdnStats" class="cdn-grid">
                <!-- Wird dynamisch gefüllt -->
            </div>
        </div>

        <!-- Charts -->
        <div class="charts-section">
            <div class="chart-container">
                <h3>📈 Hit Rate Trend</h3>
                <canvas id="hitRateChart"></canvas>
            </div>
            
            <div class="chart-container">
                <h3>🎯 CDN Hit Rates</h3>
                <canvas id="cdnChart"></canvas>
            </div>
        </div>

        <!-- Debug Sektion -->
        <div class="section">
            <h2>🔧 Debug Information</h2>
            <div class="debug-info">
                <p><strong>Metrics URL:</strong> <span id="metricsUrl">-</span></p>
                <p><strong>Last Update:</strong> <span id="lastUpdate">-</span></p>
                <p><strong>Update Interval:</strong> <span id="updateInterval">10s</span></p>
                <p><strong>Status:</strong> <span id="debugStatus">-</span></p>
            </div>
            
            <button onclick="testConnection()" class="test-button">🧪 Test Connection</button>
            <button onclick="showRawMetrics()" class="test-button">📄 Show Raw Metrics</button>
            <button onclick="toggleAutoRefresh()" class="test-button" id="refreshButton">⏸️ Pause Refresh</button>
        </div>

        <!-- Raw Metrics Modal -->
        <div id="rawMetricsModal" class="modal">
            <div class="modal-content">
                <span class="close" onclick="closeModal()">&times;</span>
                <h2>📄 Raw Prometheus Metrics</h2>
                <pre id="rawMetricsContent">Loading...</pre>
            </div>
        </div>
    </div>

    <script>
        // Globale Variablen
        let metricsData = {};
        let updateTimer;
        let hitRateChart;
        let cdnChart;
        let hitRateHistory = [];
        let autoRefresh = true;

        // Chart-Initialisierung
        function initCharts() {
            // Hit Rate Trend Chart
            const hitRateCtx = document.getElementById('hitRateChart').getContext('2d');
            hitRateChart = new Chart(hitRateCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Hit Rate (%)',
                        data: [],
                        borderColor: '#4CAF50',
                        backgroundColor: 'rgba(76, 175, 80, 0.1)',
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100
                        }
                    }
                }
            });

            // CDN Chart
            const cdnCtx = document.getElementById('cdnChart').getContext('2d');
            cdnChart = new Chart(cdnCtx, {
                type: 'doughnut',
                data: {
                    labels: [],
                    datasets: [{
                        data: [],
                        backgroundColor: [
                            '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', 
                            '#9966FF', '#FF9F40', '#FF6384', '#C9CBCF'
                        ]
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: {
                            position: 'bottom'
                        }
                    }
                }
            });
        }

        // NEUE BANDWIDTH SAVINGS FUNKTIONEN
        function updateBandwidthMetrics(metrics) {
            console.log('=== BANDWIDTH METRICS UPDATE ===');
            
            // Extrahiere bytes_total Metriken nach hit_status
            const bytesMetrics = metrics['lancache_bytes_total'] || [];
            
            let totalMiss = 0;
            let totalHit = 0;
            let totalBypass = 0;
            
            bytesMetrics.forEach(metric => {
                const hitStatus = metric.labels.hit_status;
                const bytes = metric.value;
                
                switch(hitStatus) {
                    case 'MISS':
                        totalMiss += bytes;
                        break;
                    case 'HIT':
                        totalHit += bytes;
                        break;
                    case 'BYPASS':
                        totalBypass += bytes;
                        break;
                }
            });
            
            console.log('Bytes MISS:', totalMiss);
            console.log('Bytes HIT:', totalHit);
            console.log('Bytes BYPASS:', totalBypass);
            
            // Berechnungen
            const totalServed = totalMiss + totalHit + totalBypass;
            const savingsRatio = totalMiss + totalHit > 0 ? (totalHit / (totalMiss + totalHit)) * 100 : 0;
            const internetRatio = totalMiss / (1024 * 1024 * 1024); // GB
            const cacheRatio = totalHit / (1024 * 1024 * 1024); // GB
            
            // Update UI
            document.getElementById('internetDownloads').textContent = formatBytes(totalMiss);
            document.getElementById('internetDownloadsDetail').textContent = `${formatNumber(totalMiss / (1024 * 1024))} MB downloaded`;
            
            document.getElementById('cacheServed').textContent = formatBytes(totalHit);
            document.getElementById('cacheServedDetail').textContent = `${formatNumber(totalHit / (1024 * 1024))} MB from cache`;
            
            document.getElementById('bandwidthSaved').textContent = formatBytes(totalHit);
            document.getElementById('savingsDetail').textContent = `${savingsRatio.toFixed(1)}% traffic reduction`;
            
            document.getElementById('efficiencyRate').textContent = `${savingsRatio.toFixed(1)}%`;
            document.getElementById('efficiencyDetail').textContent = `${(100 - savingsRatio).toFixed(1)}% internet usage`;
            
            // Traffic Ratio
            const ratio = internetRatio > 0 ? (cacheRatio / internetRatio).toFixed(1) : '∞';
            document.getElementById('trafficRatio').textContent = `1:${ratio}`;
            document.getElementById('ratioDetail').textContent = `${internetRatio.toFixed(1)}GB : ${cacheRatio.toFixed(1)}GB`;
            
            // Cost Savings (Beispielrechnung: €0.10/GB)
            const costPerGB = 0.10; // Euro pro GB
            const monthlySavings = (totalHit / (1024 * 1024 * 1024)) * costPerGB;
            document.getElementById('costSavings').textContent = `€${monthlySavings.toFixed(2)}`;
            document.getElementById('costDetail').textContent = `At €${costPerGB}/GB rate`;
            
            console.log('=== BANDWIDTH METRICS COMPLETE ===');
        }

        // Metriken abrufen und parsen
        async function fetchMetrics() {
            const metricsUrl = document.getElementById('metricsUrl').textContent || CONFIG.metricsUrl;
            
            try {
                let response;
                
                // Versuche zunächst relativen Pfad (Proxy)
                try {
                    response = await fetch(CONFIG.metricsUrl);
                    if (!response.ok) throw new Error('Proxy failed');
                } catch (proxyError) {
                    // Fallback auf direkte URL
                    response = await fetch(CONFIG.fallbackUrl);
                }

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const text = await response.text();
                document.getElementById('debugStatus').textContent = `✅ OK (${response.status})`;
                document.getElementById('metricsUrl').textContent = response.url;
                
                return parsePrometheusMetrics(text);
                
            } catch (error) {
                console.error('Fehler beim Abrufen der Metriken:', error);
                document.getElementById('debugStatus').textContent = `❌ Error: ${error.message}`;
                throw error;
            }
        }

        // Prometheus-Metriken parsen
        function parsePrometheusMetrics(text) {
            const metrics = {};
            const lines = text.split('\n');

            lines.forEach(line => {
                // Überspringe Kommentare und leere Zeilen
                if (line.startsWith('#') || !line.trim()) return;

                // Parse Metrik-Zeile: metric_name{labels} value
                const match = line.match(/^([a-zA-Z_:][a-zA-Z0-9_:]*)(\{.*?\})?\s+([\d\.\-]+(?:e[\+\-]?\d+)?)$/i);
                if (!match) return;

                const [, name, labelsStr, value] = match;
                const labels = parseLabels(labelsStr || '');

                if (!metrics[name]) metrics[name] = [];
                metrics[name].push({
                    labels,
                    value: parseFloat(value)
                });
            });

            return metrics;
        }

        function parsePrometheusValue(valueStr) {
            const cleanValue = String(valueStr).replace(/['"]/g, '').trim();
    
            if (cleanValue.includes('e') || cleanValue.length > 10) {
                console.log('Parsing large/scientific number:', cleanValue);
            }
    
            const parsed = parseFloat(cleanValue);
            return isNaN(parsed) ? 0 : parsed;
        }

        function parseMetrics(metricsText) {
            // Suche nach neuer bytes_served_total Metrik
            const bytesMatch = metricsText.match(/lancache_bytes_served_total\s+([\d\.e\+\-]+)/i);
    
            if (bytesMatch) {
                const bytesValue = parsePrometheusValue(bytesMatch[1]);
                document.getElementById('totalBytes').textContent = formatBytes(bytesValue);
            }
        }
    
        // Labels parsen
        function parseLabels(labelsStr) {
            const labels = {};
            if (!labelsStr) return labels;

            const cleanStr = labelsStr.slice(1, -1); // Entferne { }
            const pairs = cleanStr.match(/\w+="[^"]*"/g) || [];

            pairs.forEach(pair => {
                const [key, value] = pair.split('=');
                labels[key] = value.slice(1, -1); // Entferne Anführungszeichen
            });

            return labels;
        }

        // UI aktualisieren (ERWEITERT)
        function updateUI(metrics) {
            metricsData = metrics;

            // Bestehende Updates
            updateTotalRequests(metrics);
            updateHitRate(metrics);
            updateCacheStats(metrics);
            updateBytesServed(metrics);
            updateActiveConnections(metrics);
            updateUptime(metrics);
            updateCDNStats(metrics);
            
            // ✅ NEU: Bandwidth Savings
            updateBandwidthMetrics(metrics);

            // Charts aktualisieren
            updateCharts(metrics);

            // Status
            document.getElementById('statusDot').className = 'status-indicator online';
            document.getElementById('statusText').textContent = 'Online';
            document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
        }

        function updateTotalRequests(metrics) {
            const requests = metrics['lancache_requests_total'] || [];
            const total = requests.reduce((sum, metric) => sum + metric.value, 0);
            document.getElementById('totalRequests').textContent = formatNumber(total);
        }

        function updateHitRate(metrics) {
            const hitRate = metrics['lancache_hit_rate'];
            if (hitRate && hitRate.length > 0) {
                const rate = (hitRate[0].value * 100).toFixed(1);
                document.getElementById('hitRate').textContent = `${rate}%`;
                
                // Hit Rate History für Chart
                const now = new Date().toLocaleTimeString();
                hitRateHistory.push({ time: now, rate: parseFloat(rate) });
                if (hitRateHistory.length > CONFIG.maxDataPoints) {
                    hitRateHistory.shift();
                }
            } else {
                // Fallback: Berechne aus Hits/Misses
                const hits = metrics['lancache_cache_hits_total'] || [];
                const misses = metrics['lancache_cache_misses_total'] || [];
                
                const totalHits = hits.reduce((sum, metric) => sum + metric.value, 0);
                const totalMisses = misses.reduce((sum, metric) => sum + metric.value, 0);
                const totalRequests = totalHits + totalMisses;
                
                if (totalRequests > 0) {
                    const rate = ((totalHits / totalRequests) * 100).toFixed(1);
                    document.getElementById('hitRate').textContent = `${rate}%`;
                } else {
                    document.getElementById('hitRate').textContent = '0%';
                }
            }
        }

        function updateCacheStats(metrics) {
            const hits = metrics['lancache_cache_hits_total'] || [];
            const misses = metrics['lancache_cache_misses_total'] || [];

            const totalHits = hits.reduce((sum, metric) => sum + metric.value, 0);
            const totalMisses = misses.reduce((sum, metric) => sum + metric.value, 0);

            document.getElementById('cacheHits').textContent = formatNumber(totalHits);
            document.getElementById('cacheMisses').textContent = formatNumber(totalMisses);
        }

        function updateBytesServed(metrics) {
            console.log('=== BYTES SERVED DEBUG ===');
    
            let totalBytes = 0;
            if (metrics['lancache_bytes_served_total']?.length > 0) {
                totalBytes = metrics['lancache_bytes_served_total'][0].value;
                console.log('Found bytes_served_total:', totalBytes);
            }
    
            document.getElementById('bytesServed').textContent = formatBytes(totalBytes);
        }

        function updateActiveConnections(metrics) {
            const connections = metrics['lancache_active_connections'];
            if (connections && connections.length > 0) {
                document.getElementById('activeConnections').textContent = formatNumber(connections[0].value);
            } else {
                document.getElementById('activeConnections').textContent = '0';
            }
        }

        function updateUptime(metrics) {
            const uptime = metrics['lancache_uptime_seconds'];
            if (uptime && uptime.length > 0) {
                document.getElementById('uptime').textContent = formatDuration(uptime[0].value);
            } else {
                document.getElementById('uptime').textContent = '-';
            }
        }

        function updateCDNStats(metrics) {
            const cdnContainer = document.getElementById('cdnStats');
            const cdnData = new Map();

            // Sammle CDN-Daten
            ['lancache_cache_hits_total', 'lancache_cache_misses_total', 'lancache_hit_rate_by_cdn'].forEach(metricName => {
                const metricList = metrics[metricName] || [];
                metricList.forEach(metric => {
                    const cdn = metric.labels.cdn;
                    if (!cdn) return;

                    if (!cdnData.has(cdn)) {
                        cdnData.set(cdn, { hits: 0, misses: 0, hitRate: 0 });
                    }

                    const data = cdnData.get(cdn);
                    if (metricName === 'lancache_cache_hits_total') {
                        data.hits = metric.value;
                    } else if (metricName === 'lancache_cache_misses_total') {
                        data.misses = metric.value;
                    } else if (metricName === 'lancache_hit_rate_by_cdn') {
                        data.hitRate = metric.value * 100;
                    }
                });
            });

            // Update CDN Count
            document.getElementById('cdnCount').textContent = cdnData.size;

            // Erstelle CDN-Cards
            cdnContainer.innerHTML = '';
            cdnData.forEach((data, cdn) => {
                const cdnCard = document.createElement('div');
                cdnCard.className = 'cdn-card';
                cdnCard.innerHTML = `
                    <h4>📦 ${cdn.toUpperCase()}</h4>
                    <div class="cdn-stats">
                        <div class="cdn-stat">
                            <span class="label">Hits:</span>
                            <span class="value">${formatNumber(data.hits)}</span>
                        </div>
                        <div class="cdn-stat">
                            <span class="label">Misses:</span>
                            <span class="value">${formatNumber(data.misses)}</span>
                        </div>
                        <div class="cdn-stat">
                            <span class="label">Hit Rate:</span>
                            <span class="value">${data.hitRate.toFixed(1)}%</span>
                        </div>
                    </div>
                `;
                cdnContainer.appendChild(cdnCard);
            });
        }

        function updateCharts(metrics) {
            // Hit Rate Chart
            if (hitRateHistory.length > 0) {
                hitRateChart.data.labels = hitRateHistory.map(h => h.time);
                hitRateChart.data.datasets[0].data = hitRateHistory.map(h => h.rate);
                hitRateChart.update('none');
            }

            // CDN Chart
            const cdnHits = metrics['lancache_cache_hits_total'] || [];
            const cdnLabels = [];
            const cdnValues = [];

            cdnHits.forEach(metric => {
                if (metric.labels.cdn) {
                    cdnLabels.push(metric.labels.cdn.toUpperCase());
                    cdnValues.push(metric.value);
                }
            });

            if (cdnLabels.length > 0) {
                cdnChart.data.labels = cdnLabels;
                cdnChart.data.datasets[0].data = cdnValues;
                cdnChart.update('none');
            }
        }

        // Hilfsfunktionen
        function formatNumber(num) {
            if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
            if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
            return Math.round(num).toString();
        }

        function formatBytes(bytes) {
            const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
            if (bytes === 0) return '0 B';
            const i = Math.floor(Math.log(bytes) / Math.log(1024));
            return Math.round((bytes / Math.pow(1024, i)) * 100) / 100 + ' ' + sizes[i];
        }

        function formatDuration(seconds) {
            const days = Math.floor(seconds / 86400);
            const hours = Math.floor((seconds % 86400) / 3600);
            const mins = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);

            if (days > 0) return `${days}d ${hours}h`;
            if (hours > 0) return `${hours}h ${mins}m`;
            if (mins > 0) return `${mins}m ${secs}s`;
            return `${secs}s`;
        }

        // Event Handler
        async function testConnection() {
            document.getElementById('debugStatus').textContent = '🔄 Testing...';
            try {
                await fetchMetrics();
                alert('✅ Verbindung erfolgreich!');
            } catch (error) {
                alert(`❌ Verbindungsfehler: ${error.message}`);
            }
        }

        async function showRawMetrics() {
            const modal = document.getElementById('rawMetricsModal');
            const content = document.getElementById('rawMetricsContent');
            
            modal.style.display = 'block';
            content.textContent = 'Loading...';
            
            try {
                const response = await fetch(CONFIG.fallbackUrl);
                const text = await response.text();
                content.textContent = text;
            } catch (error) {
                content.textContent = `Error: ${error.message}`;
            }
        }

        function closeModal() {
            document.getElementById('rawMetricsModal').style.display = 'none';
        }

        function toggleAutoRefresh() {
            autoRefresh = !autoRefresh;
            const button = document.getElementById('refreshButton');
            
            if (autoRefresh) {
                button.textContent = '⏸️ Pause Refresh';
                startUpdates();
            } else {
                button.textContent = '▶️ Resume Refresh';
                if (updateTimer) {
                    clearInterval(updateTimer);
                }
            }
        }

        // Main Update Loop
        async function updateData() {
            if (!autoRefresh) return;
            
            try {
                const metrics = await fetchMetrics();
                updateUI(metrics);
            } catch (error) {
                console.error('Update failed:', error);
                document.getElementById('statusDot').className = 'status-indicator offline';
                document.getElementById('statusText').textContent = 'Offline';
                document.getElementById('debugStatus').textContent = `❌ ${error.message}`;
            }
        }

        function startUpdates() {
            updateData(); // Sofortiger erster Update
            updateTimer = setInterval(updateData, CONFIG.updateInterval);
        }

        // Initialisierung
        document.addEventListener('DOMContentLoaded', function() {
            initCharts();
            startUpdates();
            
            // Modal-Handler
            window.onclick = function(event) {
                const modal = document.getElementById('rawMetricsModal');
                if (event.target === modal) {
                    closeModal();
                }
            };
        });
    </script>
</body>
</html>